{
  "title": "Stop Using useEffect for Everything (Try Lazy Effects Instead)",
  "author": "Ammiel Yawson",
  "created_at": "2025-06-24T09:00:00.000Z",
  "primary_tag": "React",
  "featured": true,
  "feature_image": "/images/stop-using-useeffect-for-everything-try-lazy-effects-instead/featured.webp",
  "feature_dark_mode_image": "/images/stop-using-useeffect-for-everything-try-lazy-effects-instead/featured-dark.webp",
  "tags": [
    "React",
    "Vue"
  ],
  "body": {
    "raw": "\nThe best code tells a clear story: user acts → handler responds.\n\nuseEffect can break this story by separating effects from their actions, removing the direct link between user interactions and their responses. While it's the most common way we're taught to handle side effects in React, not all effects benefit from automatic execution.\n\nWhen the useEffect hook is overused, it can lead to cognitive load when looking to link effects to their causing actions.\n\nAs a developer, a huge part of your work is reading code to understand and either extend functionality or fix bugs. Hence, you always want to lean on decisions that lead to clearer code.\n\nIn the case of effects, lazy effects (sometimes known event-driven effects) are how you make sure you keep a direct link between your actions and their effects.\n\n<aside>\n💡\n\nLazy effects are side effects called in response to user events/actions. They're \"lazy\" because they wait until manually called, and \"event-driven\" because they respond to user interactions.\n\n</aside>\n\n## Let’s look at examples:\n\nSearch example\n\n```tsx\n// ❌ Reactive useEffect\nuseEffect(() => {\n  if (searchTerm.length > 2) {\n    searchUsers(searchTerm);\n  }\n}, [searchTerm]);\n\n// ✅ Lazy event-driven\nconst handleSearch = (term) => {\n  setSearchTerm(term);\n  if (term.length > 2) {\n    searchUsers(term);\n  }\n};\n```\n\n_The `searchUsers` function is clearly called inside `handleSearch`,\nestablishing a direct relation between when search handler\nand the search users effect._\n\n---\n\nModal example\n\n```tsx\n// ❌ Reactive\nuseEffect(() => {\n  if (isModalOpen) {\n    trackModalView('user-profile');\n  }\n}, [isModalOpen]);\n\n// ✅ Lazy\nconst openModal = () => {\n  setIsModalOpen(true);\n  trackModalView('user-profile');\n};\n```\n\n_Same as in the search example, There's a direct link between `openModal` handler and `trackModalView` effect._\n\n## How do you decide when to use lazy effects over useEffect?\n\nThe simple question to ask is: does it occur in response to a user action? If yes, then you mostly want to go with event driven effects.\nIf not, then useEffect is probably the right choice for reactive updates like data syncing or cleanup operations.\n",
    "html": "<p>The best code tells a clear story: user acts → handler responds.</p>\n<p>useEffect can break this story by separating effects from their actions, removing the direct link between user interactions and their responses. While it's the most common way we're taught to handle side effects in React, not all effects benefit from automatic execution.</p>\n<p>When the useEffect hook is overused, it can lead to cognitive load when looking to link effects to their causing actions.</p>\n<p>As a developer, a huge part of your work is reading code to understand and either extend functionality or fix bugs. Hence, you always want to lean on decisions that lead to clearer code.</p>\n<p>In the case of effects, lazy effects (sometimes known event-driven effects) are how you make sure you keep a direct link between your actions and their effects.</p>\n<p>Lazy effects are side effects called in response to user events/actions. They're \"lazy\" because they wait until manually called, and \"event-driven\" because they respond to user interactions.</p>\n<h2>Let’s look at examples:</h2>\n<p>Search example</p>\n<pre><code class=\"language-tsx\">// ❌ Reactive useEffect\nuseEffect(() => {\n  if (searchTerm.length > 2) {\n    searchUsers(searchTerm);\n  }\n}, [searchTerm]);\n\n// ✅ Lazy event-driven\nconst handleSearch = (term) => {\n  setSearchTerm(term);\n  if (term.length > 2) {\n    searchUsers(term);\n  }\n};\n</code></pre>\n<p><em>The <code>searchUsers</code> function is clearly called inside <code>handleSearch</code>,\nestablishing a direct relation between when search handler\nand the search users effect.</em></p>\n<hr>\n<p>Modal example</p>\n<pre><code class=\"language-tsx\">// ❌ Reactive\nuseEffect(() => {\n  if (isModalOpen) {\n    trackModalView('user-profile');\n  }\n}, [isModalOpen]);\n\n// ✅ Lazy\nconst openModal = () => {\n  setIsModalOpen(true);\n  trackModalView('user-profile');\n};\n</code></pre>\n<p><em>Same as in the search example, There's a direct link between <code>openModal</code> handler and <code>trackModalView</code> effect.</em></p>\n<h2>How do you decide when to use lazy effects over useEffect?</h2>\n<p>The simple question to ask is: does it occur in response to a user action? If yes, then you mostly want to go with event driven effects.\nIf not, then useEffect is probably the right choice for reactive updates like data syncing or cleanup operations.</p>"
  },
  "_id": "stop-using-useeffect-for-everything-try-lazy-effects-instead.mdx",
  "_raw": {
    "sourceFilePath": "stop-using-useeffect-for-everything-try-lazy-effects-instead.mdx",
    "sourceFileName": "stop-using-useeffect-for-everything-try-lazy-effects-instead.mdx",
    "sourceFileDir": ".",
    "contentType": "mdx",
    "flattenedPath": "stop-using-useeffect-for-everything-try-lazy-effects-instead"
  },
  "type": "Post",
  "slug": "stop-using-useeffect-for-everything-try-lazy-effects-instead",
  "reading_time": 2
}