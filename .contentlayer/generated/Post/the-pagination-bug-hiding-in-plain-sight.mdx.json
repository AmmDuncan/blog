{
  "title": "The Pagination Bug Thatâ€™s Hiding in Plain Sight",
  "author": "Ammiel Yawson",
  "created_at": "2025-06-17T09:00:00.000Z",
  "primary_tag": "Web Development",
  "featured": true,
  "feature_image": "/images/the-pagination-bug-hiding-in-plain-sight/featured.webp",
  "tags": [
    "Web Development",
    "React",
    "Vue"
  ],
  "body": {
    "raw": "\nAs a front-end developer, pagination is a common feature you'll work on. It usually involves a list of data, some filters, and finally, the pagination control.\n\nBut there's a simple, common gotcha that you might be hiding in your application: not resetting the page back to 1 when any filter changes.\n\n### The problem:\n\nImagine you're on page 4 of a user list page. You've still not found the user you're looking for, but you do know their first name: Fred.\n\nYou type in \"Fred\", but then you get no results found. However, you're sure you saw Fred in the user list just yesterday.\n\nAs a developer yourself, you decide to investigate this issue. You notice the query sent to the backend looks like this:\n\n```tsx\n{\n  \"keyword\": \"Fred\",\n  \"page\": 4\n}\n```\n\nNow you wonder, what about page 1? Right. You would have to manually change the page number to 1 to determine if there's actually no user called \"Fred\".\n\nWith your frontend knowledge, you were able to catch this. You checked the network when you didn't get the results you were expecting.\n\nWill your non-dev user have the urge to check the network? I'm guessing not. That means you end up misleading your users.\n\nTo fix this, always reset the page query to 1 whenever other queries are changed.\n\nHere are implementations in both React and Vue that I have used in the past to avoid this bug:\n\n### React\n\n````tsx\nimport { useCallback, useReducer } from 'react';\n\ntype QueryObject = Record<string, string | number>;\n\nfunction spreadReducer<\n  TState extends QueryObject,\n  TAction extends Partial<TState>,\n>(state: TState, action: TAction) {\n  return {\n    ...state,\n    ...action,\n  };\n}\n\n/**\n * Hook to manage a query object. Automatically reset to page `1` when other\n * query keys are changed\n *\n * @param initialQueryState - initial state of your query\n * @returns an object containing the query object and the function to update the object\n *\n * @example\n * ```\n * function SomePageComponent() {\n *   const { query, updateQuery } = usePageResetQuery({ keyword: '', page: 1, pageSize: 10 })\n *   const handleSearchChange = (searchValue) => updateQuery({ keyword: searchValue })\n *   return (\n *     <div>\n *       <input type=\"search\" onChange={(e) => handleSearchChange(e.target.value)} />\n *       {/* ... *\\/}\n *     </div>\n *   )\n * }\n * ```\n */\nexport function usePageResetQuery<T extends QueryObject>(initialQueryState: T) {\n  const [query, updateQuery] = useReducer(\n    spreadReducer,\n    null,\n    () => initialQueryState\n  );\n\n  const modifiedUpdateQuery: typeof updateQuery = useCallback((action) => {\n    if ('page' in action) {\n      updateQuery(action);\n    } else {\n      updateQuery({\n        ...action,\n        page: 1,\n      });\n    }\n  }, []);\n\n  return {\n    query,\n    updateQuery: modifiedUpdateQuery,\n  };\n}\n````\n\n### Vue\n\n```tsx\nimport { reactive, computed } from 'vue';\n\ntype QueryObject = Record<string, string | number>;\n\nexport function usePageResetQuery<T extends QueryObject>(initialQueryState: T) {\n  const query = reactive({ ...initialQueryState });\n\n  const updateQuery = (updates: Partial<T>) => {\n    if ('page' in updates) {\n      Object.assign(query, updates);\n    } else {\n      Object.assign(query, { ...updates, page: 1 });\n    }\n  };\n\n  return {\n    query: computed(() => query),\n    updateQuery,\n  };\n}\n```\n",
    "html": "<p>As a front-end developer, pagination is a common feature you'll work on. It usually involves a list of data, some filters, and finally, the pagination control.</p>\n<p>But there's a simple, common gotcha that you might be hiding in your application: not resetting the page back to 1 when any filter changes.</p>\n<h3>The problem:</h3>\n<p>Imagine you're on page 4 of a user list page. You've still not found the user you're looking for, but you do know their first name: Fred.</p>\n<p>You type in \"Fred\", but then you get no results found. However, you're sure you saw Fred in the user list just yesterday.</p>\n<p>As a developer yourself, you decide to investigate this issue. You notice the query sent to the backend looks like this:</p>\n<pre><code class=\"language-tsx\">{\n  \"keyword\": \"Fred\",\n  \"page\": 4\n}\n</code></pre>\n<p>Now you wonder, what about page 1? Right. You would have to manually change the page number to 1 to determine if there's actually no user called \"Fred\".</p>\n<p>With your frontend knowledge, you were able to catch this. You checked the network when you didn't get the results you were expecting.</p>\n<p>Will your non-dev user have the urge to check the network? I'm guessing not. That means you end up misleading your users.</p>\n<p>To fix this, always reset the page query to 1 whenever other queries are changed.</p>\n<p>Here are implementations in both React and Vue that I have used in the past to avoid this bug:</p>\n<h3>React</h3>\n<pre><code class=\"language-tsx\">import { useCallback, useReducer } from 'react';\n\ntype QueryObject = Record&#x3C;string, string | number>;\n\nfunction spreadReducer&#x3C;\n  TState extends QueryObject,\n  TAction extends Partial&#x3C;TState>,\n>(state: TState, action: TAction) {\n  return {\n    ...state,\n    ...action,\n  };\n}\n\n/**\n * Hook to manage a query object. Automatically reset to page `1` when other\n * query keys are changed\n *\n * @param initialQueryState - initial state of your query\n * @returns an object containing the query object and the function to update the object\n *\n * @example\n * ```\n * function SomePageComponent() {\n *   const { query, updateQuery } = usePageResetQuery({ keyword: '', page: 1, pageSize: 10 })\n *   const handleSearchChange = (searchValue) => updateQuery({ keyword: searchValue })\n *   return (\n *     &#x3C;div>\n *       &#x3C;input type=\"search\" onChange={(e) => handleSearchChange(e.target.value)} />\n *       {/* ... *\\/}\n *     &#x3C;/div>\n *   )\n * }\n * ```\n */\nexport function usePageResetQuery&#x3C;T extends QueryObject>(initialQueryState: T) {\n  const [query, updateQuery] = useReducer(\n    spreadReducer,\n    null,\n    () => initialQueryState\n  );\n\n  const modifiedUpdateQuery: typeof updateQuery = useCallback((action) => {\n    if ('page' in action) {\n      updateQuery(action);\n    } else {\n      updateQuery({\n        ...action,\n        page: 1,\n      });\n    }\n  }, []);\n\n  return {\n    query,\n    updateQuery: modifiedUpdateQuery,\n  };\n}\n</code></pre>\n<h3>Vue</h3>\n<pre><code class=\"language-tsx\">import { reactive, computed } from 'vue';\n\ntype QueryObject = Record&#x3C;string, string | number>;\n\nexport function usePageResetQuery&#x3C;T extends QueryObject>(initialQueryState: T) {\n  const query = reactive({ ...initialQueryState });\n\n  const updateQuery = (updates: Partial&#x3C;T>) => {\n    if ('page' in updates) {\n      Object.assign(query, updates);\n    } else {\n      Object.assign(query, { ...updates, page: 1 });\n    }\n  };\n\n  return {\n    query: computed(() => query),\n    updateQuery,\n  };\n}\n</code></pre>"
  },
  "_id": "the-pagination-bug-hiding-in-plain-sight.mdx",
  "_raw": {
    "sourceFilePath": "the-pagination-bug-hiding-in-plain-sight.mdx",
    "sourceFileName": "the-pagination-bug-hiding-in-plain-sight.mdx",
    "sourceFileDir": ".",
    "contentType": "mdx",
    "flattenedPath": "the-pagination-bug-hiding-in-plain-sight"
  },
  "type": "Post",
  "slug": "the-pagination-bug-hiding-in-plain-sight",
  "reading_time": 3
}